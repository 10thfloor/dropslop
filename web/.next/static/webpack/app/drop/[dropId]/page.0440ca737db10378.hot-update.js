"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/drop/[dropId]/page",{

/***/ "(app-pages-browser)/./hooks/use-sse.ts":
/*!**************************!*\
  !*** ./hooks/use-sse.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSSE: () => (/* binding */ useSSE)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.6_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.6_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ useSSE auto */ \nconst defaultDropState = {\n    phase: \"registration\",\n    inventory: 0,\n    participantCount: 0,\n    totalTickets: 0,\n    winnerCount: 0,\n    registrationEnd: 0,\n    purchaseEnd: undefined\n};\nconst defaultUserState = {\n    status: \"not_registered\",\n    tickets: 0\n};\nfunction useSSE(param) {\n    let { dropId, userId, enabled = true } = param;\n    const [dropState, setDropState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultDropState);\n    const [userState, setUserState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultUserState);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [clockOffset, setClockOffset] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const eventSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    /**\n   * Update clock offset from server time\n   * Uses exponential moving average to smooth out network jitter\n   */ const updateClockOffset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSE.useCallback[updateClockOffset]\": (serverTime)=>{\n            if (!serverTime) return;\n            const clientTime = Date.now();\n            const newOffset = serverTime - clientTime;\n            setClockOffset({\n                \"useSSE.useCallback[updateClockOffset]\": (prevOffset)=>{\n                    // If this is the first measurement, use it directly\n                    if (prevOffset === 0) return newOffset;\n                    // Exponential moving average (alpha = 0.3) to smooth jitter\n                    // Prevents countdown from jumping around due to network latency\n                    const alpha = 0.3;\n                    return Math.round(prevOffset * (1 - alpha) + newOffset * alpha);\n                }\n            }[\"useSSE.useCallback[updateClockOffset]\"]);\n        }\n    }[\"useSSE.useCallback[updateClockOffset]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSE.useCallback[connect]\": ()=>{\n            if (!enabled || !userId) return;\n            // Clean up existing connection\n            if (eventSourceRef.current) {\n                eventSourceRef.current.close();\n            }\n            // Connect directly to SSE server (Next.js proxy doesn't handle SSE well)\n            const sseBaseUrl = process.env.NEXT_PUBLIC_SSE_URL || \"http://localhost:3004\";\n            const url = \"\".concat(sseBaseUrl, \"/events/\").concat(dropId, \"/\").concat(userId);\n            const eventSource = new EventSource(url);\n            eventSourceRef.current = eventSource;\n            eventSource.onopen = ({\n                \"useSSE.useCallback[connect]\": ()=>{\n                    setConnected(true);\n                    setError(null);\n                }\n            })[\"useSSE.useCallback[connect]\"];\n            eventSource.addEventListener(\"connected\", {\n                \"useSSE.useCallback[connect]\": (e)=>{\n                    try {\n                        const data = JSON.parse(e.data);\n                        if (data.type === \"connected\") {\n                            // Sync clock on initial connection\n                            updateClockOffset(data.serverTime);\n                            setDropState({\n                                \"useSSE.useCallback[connect]\": (prev)=>({\n                                        ...prev,\n                                        phase: data.phase,\n                                        totalTickets: data.totalTickets || 0,\n                                        registrationEnd: data.registrationEnd || 0,\n                                        purchaseEnd: data.purchaseEnd\n                                    })\n                            }[\"useSSE.useCallback[connect]\"]);\n                        }\n                    } catch (err) {\n                        console.error(\"Failed to parse connected event:\", err);\n                    }\n                }\n            }[\"useSSE.useCallback[connect]\"]);\n            eventSource.addEventListener(\"drop\", {\n                \"useSSE.useCallback[connect]\": (e)=>{\n                    try {\n                        const data = JSON.parse(e.data);\n                        if (data.type === \"drop\") {\n                            // Update clock offset on each poll\n                            updateClockOffset(data.serverTime);\n                            setDropState({\n                                \"useSSE.useCallback[connect]\": (prev)=>({\n                                        ...prev,\n                                        phase: data.phase,\n                                        inventory: data.inventory,\n                                        participantCount: data.participantCount,\n                                        totalTickets: data.totalTickets || 0,\n                                        registrationEnd: data.registrationEnd\n                                    })\n                            }[\"useSSE.useCallback[connect]\"]);\n                        }\n                    } catch (err) {\n                        console.error(\"Failed to parse drop event:\", err);\n                    }\n                }\n            }[\"useSSE.useCallback[connect]\"]);\n            eventSource.addEventListener(\"user\", {\n                \"useSSE.useCallback[connect]\": (e)=>{\n                    try {\n                        const data = JSON.parse(e.data);\n                        if (data.type === \"user\") {\n                            setUserState({\n                                status: data.status,\n                                tickets: data.tickets || 0,\n                                queuePosition: data.position,\n                                purchaseToken: data.token,\n                                rolloverUsed: data.rolloverUsed,\n                                rolloverBalance: data.rolloverBalance\n                            });\n                        }\n                    } catch (err) {\n                        console.error(\"Failed to parse user event:\", err);\n                    }\n                }\n            }[\"useSSE.useCallback[connect]\"]);\n            eventSource.onerror = ({\n                \"useSSE.useCallback[connect]\": ()=>{\n                    setConnected(false);\n                    setError(\"Connection lost\");\n                    eventSource.close();\n                    // Reconnect after 3 seconds\n                    reconnectTimeoutRef.current = setTimeout({\n                        \"useSSE.useCallback[connect]\": ()=>{\n                            connect();\n                        }\n                    }[\"useSSE.useCallback[connect]\"], 3000);\n                }\n            })[\"useSSE.useCallback[connect]\"];\n        }\n    }[\"useSSE.useCallback[connect]\"], [\n        dropId,\n        userId,\n        enabled,\n        updateClockOffset\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSE.useEffect\": ()=>{\n            connect();\n            return ({\n                \"useSSE.useEffect\": ()=>{\n                    if (eventSourceRef.current) {\n                        eventSourceRef.current.close();\n                    }\n                    if (reconnectTimeoutRef.current) {\n                        clearTimeout(reconnectTimeoutRef.current);\n                    }\n                }\n            })[\"useSSE.useEffect\"];\n        }\n    }[\"useSSE.useEffect\"], [\n        connect\n    ]);\n    return {\n        dropState,\n        userState,\n        connected,\n        error,\n        clockOffset\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Vzs0QkFDdkMzQjt3QkFDRjtzREFBRztnQkFDTDs7UUFDRjtzQ0FBRztRQUFDekI7UUFBUUM7UUFBUUM7UUFBU2E7S0FBa0I7SUFFL0NoQyxnREFBU0E7NEJBQUM7WUFDUjBDO1lBRUE7b0NBQU87b0JBQ0wsSUFBSVosZUFBZWEsT0FBTyxFQUFFO3dCQUMxQmIsZUFBZWEsT0FBTyxDQUFDQyxLQUFLO29CQUM5QjtvQkFDQSxJQUFJYixvQkFBb0JZLE9BQU8sRUFBRTt3QkFDL0IyQixhQUFhdkMsb0JBQW9CWSxPQUFPO29CQUMxQztnQkFDRjs7UUFDRjsyQkFBRztRQUFDRDtLQUFRO0lBRVosT0FBTztRQUFFdEI7UUFBV0U7UUFBV0U7UUFBV0U7UUFBT0U7SUFBWTtBQUMvRCIsInNvdXJjZXMiOlsiL1VzZXJzL21rL0Rlc2t0b3Avd2FpdGluZyByb29tL3dlYi9ob29rcy91c2Utc3NlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IERyb3BTdGF0ZSwgVXNlclN0YXRlLCBTU0VFdmVudCB9IGZyb20gXCJAL2xpYi90eXBlc1wiO1xuXG5pbnRlcmZhY2UgVXNlU1NFT3B0aW9ucyB7XG4gIGRyb3BJZDogc3RyaW5nO1xuICB1c2VySWQ6IHN0cmluZyB8IG51bGw7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgVXNlU1NFUmV0dXJuIHtcbiAgZHJvcFN0YXRlOiBEcm9wU3RhdGU7XG4gIHVzZXJTdGF0ZTogVXNlclN0YXRlO1xuICBjb25uZWN0ZWQ6IGJvb2xlYW47XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBjbG9ja09mZnNldDogbnVtYmVyOyAvLyBzZXJ2ZXJUaW1lIC0gY2xpZW50VGltZSAoZm9yIGNvdW50ZG93biBzeW5jKVxufVxuXG5jb25zdCBkZWZhdWx0RHJvcFN0YXRlOiBEcm9wU3RhdGUgPSB7XG4gIHBoYXNlOiBcInJlZ2lzdHJhdGlvblwiLFxuICBpbnZlbnRvcnk6IDAsXG4gIHBhcnRpY2lwYW50Q291bnQ6IDAsXG4gIHRvdGFsVGlja2V0czogMCxcbiAgd2lubmVyQ291bnQ6IDAsXG4gIHJlZ2lzdHJhdGlvbkVuZDogMCxcbiAgcHVyY2hhc2VFbmQ6IHVuZGVmaW5lZCxcbn07XG5cbmNvbnN0IGRlZmF1bHRVc2VyU3RhdGU6IFVzZXJTdGF0ZSA9IHtcbiAgc3RhdHVzOiBcIm5vdF9yZWdpc3RlcmVkXCIsXG4gIHRpY2tldHM6IDAsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU1NFKHtcbiAgZHJvcElkLFxuICB1c2VySWQsXG4gIGVuYWJsZWQgPSB0cnVlLFxufTogVXNlU1NFT3B0aW9ucyk6IFVzZVNTRVJldHVybiB7XG4gIGNvbnN0IFtkcm9wU3RhdGUsIHNldERyb3BTdGF0ZV0gPSB1c2VTdGF0ZTxEcm9wU3RhdGU+KGRlZmF1bHREcm9wU3RhdGUpO1xuICBjb25zdCBbdXNlclN0YXRlLCBzZXRVc2VyU3RhdGVdID0gdXNlU3RhdGU8VXNlclN0YXRlPihkZWZhdWx0VXNlclN0YXRlKTtcbiAgY29uc3QgW2Nvbm5lY3RlZCwgc2V0Q29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2Nsb2NrT2Zmc2V0LCBzZXRDbG9ja09mZnNldF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgZXZlbnRTb3VyY2VSZWYgPSB1c2VSZWY8RXZlbnRTb3VyY2UgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVjb25uZWN0VGltZW91dFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgY2xvY2sgb2Zmc2V0IGZyb20gc2VydmVyIHRpbWVcbiAgICogVXNlcyBleHBvbmVudGlhbCBtb3ZpbmcgYXZlcmFnZSB0byBzbW9vdGggb3V0IG5ldHdvcmsgaml0dGVyXG4gICAqL1xuICBjb25zdCB1cGRhdGVDbG9ja09mZnNldCA9IHVzZUNhbGxiYWNrKChzZXJ2ZXJUaW1lOiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcbiAgICBpZiAoIXNlcnZlclRpbWUpIHJldHVybjtcblxuICAgIGNvbnN0IGNsaWVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG5ld09mZnNldCA9IHNlcnZlclRpbWUgLSBjbGllbnRUaW1lO1xuXG4gICAgc2V0Q2xvY2tPZmZzZXQoKHByZXZPZmZzZXQpID0+IHtcbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IG1lYXN1cmVtZW50LCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgIGlmIChwcmV2T2Zmc2V0ID09PSAwKSByZXR1cm4gbmV3T2Zmc2V0O1xuXG4gICAgICAvLyBFeHBvbmVudGlhbCBtb3ZpbmcgYXZlcmFnZSAoYWxwaGEgPSAwLjMpIHRvIHNtb290aCBqaXR0ZXJcbiAgICAgIC8vIFByZXZlbnRzIGNvdW50ZG93biBmcm9tIGp1bXBpbmcgYXJvdW5kIGR1ZSB0byBuZXR3b3JrIGxhdGVuY3lcbiAgICAgIGNvbnN0IGFscGhhID0gMC4zO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQocHJldk9mZnNldCAqICgxIC0gYWxwaGEpICsgbmV3T2Zmc2V0ICogYWxwaGEpO1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXVzZXJJZCkgcmV0dXJuO1xuXG4gICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgY29ubmVjdGlvblxuICAgIGlmIChldmVudFNvdXJjZVJlZi5jdXJyZW50KSB7XG4gICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gQ29ubmVjdCBkaXJlY3RseSB0byBTU0Ugc2VydmVyIChOZXh0LmpzIHByb3h5IGRvZXNuJ3QgaGFuZGxlIFNTRSB3ZWxsKVxuICAgIGNvbnN0IHNzZUJhc2VVcmwgPVxuICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1NFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwNFwiO1xuICAgIGNvbnN0IHVybCA9IGAke3NzZUJhc2VVcmx9L2V2ZW50cy8ke2Ryb3BJZH0vJHt1c2VySWR9YDtcbiAgICBjb25zdCBldmVudFNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSh1cmwpO1xuICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQgPSBldmVudFNvdXJjZTtcblxuICAgIGV2ZW50U291cmNlLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHNldENvbm5lY3RlZCh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgIH07XG5cbiAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiY29ubmVjdGVkXCIsIChlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShlLmRhdGEpIGFzIFNTRUV2ZW50O1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgLy8gU3luYyBjbG9jayBvbiBpbml0aWFsIGNvbm5lY3Rpb25cbiAgICAgICAgICB1cGRhdGVDbG9ja09mZnNldChkYXRhLnNlcnZlclRpbWUpO1xuXG4gICAgICAgICAgc2V0RHJvcFN0YXRlKChwcmV2KSA9PiAoe1xuICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgIHBoYXNlOiBkYXRhLnBoYXNlLFxuICAgICAgICAgICAgdG90YWxUaWNrZXRzOiBkYXRhLnRvdGFsVGlja2V0cyB8fCAwLFxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uRW5kOiBkYXRhLnJlZ2lzdHJhdGlvbkVuZCB8fCAwLFxuICAgICAgICAgICAgcHVyY2hhc2VFbmQ6IGRhdGEucHVyY2hhc2VFbmQsXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBjb25uZWN0ZWQgZXZlbnQ6XCIsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCAoZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZS5kYXRhKSBhcyBTU0VFdmVudDtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gXCJkcm9wXCIpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgY2xvY2sgb2Zmc2V0IG9uIGVhY2ggcG9sbFxuICAgICAgICAgIHVwZGF0ZUNsb2NrT2Zmc2V0KGRhdGEuc2VydmVyVGltZSk7XG5cbiAgICAgICAgICBzZXREcm9wU3RhdGUoKHByZXYpID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgcGhhc2U6IGRhdGEucGhhc2UsXG4gICAgICAgICAgICBpbnZlbnRvcnk6IGRhdGEuaW52ZW50b3J5LFxuICAgICAgICAgICAgcGFydGljaXBhbnRDb3VudDogZGF0YS5wYXJ0aWNpcGFudENvdW50LFxuICAgICAgICAgICAgdG90YWxUaWNrZXRzOiBkYXRhLnRvdGFsVGlja2V0cyB8fCAwLFxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uRW5kOiBkYXRhLnJlZ2lzdHJhdGlvbkVuZCxcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGRyb3AgZXZlbnQ6XCIsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwidXNlclwiLCAoZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZS5kYXRhKSBhcyBTU0VFdmVudDtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgICBzZXRVc2VyU3RhdGUoe1xuICAgICAgICAgICAgc3RhdHVzOiBkYXRhLnN0YXR1cyxcbiAgICAgICAgICAgIHRpY2tldHM6IGRhdGEudGlja2V0cyB8fCAwLFxuICAgICAgICAgICAgcXVldWVQb3NpdGlvbjogZGF0YS5wb3NpdGlvbixcbiAgICAgICAgICAgIHB1cmNoYXNlVG9rZW46IGRhdGEudG9rZW4sXG4gICAgICAgICAgICByb2xsb3ZlclVzZWQ6IGRhdGEucm9sbG92ZXJVc2VkLFxuICAgICAgICAgICAgcm9sbG92ZXJCYWxhbmNlOiBkYXRhLnJvbGxvdmVyQmFsYW5jZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgdXNlciBldmVudDpcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGV2ZW50U291cmNlLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBzZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgc2V0RXJyb3IoXCJDb25uZWN0aW9uIGxvc3RcIik7XG4gICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuXG4gICAgICAvLyBSZWNvbm5lY3QgYWZ0ZXIgMyBzZWNvbmRzXG4gICAgICByZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29ubmVjdCgpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgfTtcbiAgfSwgW2Ryb3BJZCwgdXNlcklkLCBlbmFibGVkLCB1cGRhdGVDbG9ja09mZnNldF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29ubmVjdCgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChldmVudFNvdXJjZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Nvbm5lY3RdKTtcblxuICByZXR1cm4geyBkcm9wU3RhdGUsIHVzZXJTdGF0ZSwgY29ubmVjdGVkLCBlcnJvciwgY2xvY2tPZmZzZXQgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiZGVmYXVsdERyb3BTdGF0ZSIsInBoYXNlIiwiaW52ZW50b3J5IiwicGFydGljaXBhbnRDb3VudCIsInRvdGFsVGlja2V0cyIsIndpbm5lckNvdW50IiwicmVnaXN0cmF0aW9uRW5kIiwicHVyY2hhc2VFbmQiLCJ1bmRlZmluZWQiLCJkZWZhdWx0VXNlclN0YXRlIiwic3RhdHVzIiwidGlja2V0cyIsInVzZVNTRSIsImRyb3BJZCIsInVzZXJJZCIsImVuYWJsZWQiLCJkcm9wU3RhdGUiLCJzZXREcm9wU3RhdGUiLCJ1c2VyU3RhdGUiLCJzZXRVc2VyU3RhdGUiLCJjb25uZWN0ZWQiLCJzZXRDb25uZWN0ZWQiLCJlcnJvciIsInNldEVycm9yIiwiY2xvY2tPZmZzZXQiLCJzZXRDbG9ja09mZnNldCIsImV2ZW50U291cmNlUmVmIiwicmVjb25uZWN0VGltZW91dFJlZiIsInVwZGF0ZUNsb2NrT2Zmc2V0Iiwic2VydmVyVGltZSIsImNsaWVudFRpbWUiLCJEYXRlIiwibm93IiwibmV3T2Zmc2V0IiwicHJldk9mZnNldCIsImFscGhhIiwiTWF0aCIsInJvdW5kIiwiY29ubmVjdCIsImN1cnJlbnQiLCJjbG9zZSIsInNzZUJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1NFX1VSTCIsInVybCIsImV2ZW50U291cmNlIiwiRXZlbnRTb3VyY2UiLCJvbm9wZW4iLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJ0eXBlIiwicHJldiIsImVyciIsImNvbnNvbGUiLCJxdWV1ZVBvc2l0aW9uIiwicG9zaXRpb24iLCJwdXJjaGFzZVRva2VuIiwidG9rZW4iLCJyb2xsb3ZlclVzZWQiLCJyb2xsb3ZlckJhbGFuY2UiLCJvbmVycm9yIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-sse.ts\n"));

/***/ })

});